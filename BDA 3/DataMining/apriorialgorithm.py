# -*- coding: utf-8 -*-
"""aprioriAlgorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-TUz_wuOnj96d4uZrAZ5ES3Vw0R2aO1L
"""

from itertools import combinations
from operator import itemgetter
import pandas as pd
from time import time
import itertools

#load dataset
datasetURL='https://raw.githubusercontent.com/abhashpanwar/BDA/master/DataMining/aprioriAlgo_dataset.csv'
table = pd.read_csv(datasetURL,error_bad_lines=False)
print(table)

support=2 #min support
minimum_confidence=30 #30%

def aprioriAlgo(data, support_count):
    #\ is used of indent

    #generate list of single items 
    single_items = (data['items'].str.split(",", expand=True))\
        .apply(pd.value_counts).sum(axis=1).where(lambda value: value >= support_count).dropna()
    
    #create dataframe of items with support 
    apriori_data = pd.DataFrame(
        {'items': single_items.index.astype(str), 'support': single_items.values, 'Li': 1})

    data['Li'] = data['items'].str.count(",") + 1

    data['items'] = data['items'].apply(lambda row: set(map(str, row.split(","))))
    
    #first candidate itemset C1
    single_items_set = set(single_items.index.astype(str))

    #loop for frequent items
    for length in range(2, len(single_items_set) + 1):
        data = data[data['Li'] >= length]        
        d = data['items'] \
            .apply(lambda st: pd.Series(s if set(s).issubset(st) else None for s in combinations(single_items_set, length))) \
            .apply(lambda col: [col.dropna().unique()[0], col.count()] if col.count() >= support_count else None).dropna()
        if d.empty:
            break
        apriori_data = apriori_data.append(pd.DataFrame(
            {'items': list(map(itemgetter(0), d.values)), 'support': list(map(itemgetter(1), d.values)),
             'Li': length}), ignore_index=True)

    return apriori_data

df=aprioriAlgo(data=table, support_count=support) #call function to find frequent items

for i in df.Li.unique():
  print('L{}:'.format(i))
  print(df[df['Li']==i][['items','support']].to_string(index=False))

lastIndex=df.Li.unique()[-1]
print("Largest Frequent Items:")
for i in df[df['Li']==lastIndex][['items']].values:
  print(",".join(sorted(i.item())))

"""## **Find Association**"""

#no. items in association rules
totalConfidence=len(df[df['Li']==lastIndex][['items']].values.flatten()[0])*2*len(df[df['Li']==lastIndex][['items']].values.flatten())

confidenceTable=pd.DataFrame()
confidenceTable['item']=list(range(totalConfidence))

def get_pairs(left,right):
  lst=[]
  for i in range(len(left)):
    temp="".join(left[i])+'->'+str(right[i])
    lst.append(temp)
  for i in range(len(left)):
    temp=str(right[i])+'->'+"".join(left[i])
    lst.append(temp)
  return lst

def generatePairs():
  allelements=[]
  for i in df[df['Li']==lastIndex][['items']].values:
    temp=list(sorted(i.item()))
    res = list(zip(temp, temp[1:] + temp[:1])) 
    left = [[(temp[i]), temp[(i + 1) % len(temp)]]  
            for i in range(len(temp))] 
    right = [temp[(i + 1) % len(temp)-2]  for i in range(len(temp))]    
    allelements.append(get_pairs(left,right))
  return allelements

#generate all possible subsets of frequent items
a=generatePairs()
finalList=list(itertools.chain.from_iterable(a))
print(finalList)

confidenceTable['item']=finalList
confidenceTable['confidence']=0
"""confidenceTable""";

for k in range(len(confidenceTable)):
  l1=list(confidenceTable.iloc[k].values[0].split('->')[0])
  l2=list(confidenceTable.iloc[k].values[0].split('->')[1])
  l2=l1+l2

  #left->right i.e AB->E
  union_count=0
  left_count=0
  for i in table['items']:
    check1 =  all(item in i for item in l1) 
    check2 =  all(item in i for item in l2)
    if check1 is True:
      union_count+=1 #support of left 
    if check2 is True:
      left_count+=1 #support of left union right
  confi=round(left_count/union_count*100,2)
  #print(k,confi)
  confidenceTable.loc[k,'confidence']=confi

#print(confidenceTable)

print("Selected Association Rules with confidence {}%:".format(minimum_confidence))
print(confidenceTable[confidenceTable.confidence>=30])

